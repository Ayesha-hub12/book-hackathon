"use strict";(globalThis.webpackChunkros2_textbook=globalThis.webpackChunkros2_textbook||[]).push([[934],{2601(n,e,i){i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var s=i(4848),t=i(8453);const r={sidebar_position:2},o="URDF Components: Links and Joints",l={id:"urdf-structure/links-joints",title:"URDF Components: Links and Joints",description:"Understanding Robot Structure",source:"@site/docs/urdf-structure/links-joints.md",sourceDirName:"urdf-structure",slug:"/urdf-structure/links-joints",permalink:"/book-hackathon/docs/urdf-structure/links-joints",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/urdf-structure/links-joints.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Robot Structure with URDF",permalink:"/book-hackathon/docs/urdf-structure/"},next:{title:"Humanoid Robot Models and Integration with ROS 2",permalink:"/book-hackathon/docs/urdf-structure/humanoid-models"}},a={},c=[{value:"Understanding Robot Structure",id:"understanding-robot-structure",level:2},{value:"Links",id:"links",level:3},{value:"Joints",id:"joints",level:3},{value:"Complete Simple Robot Example",id:"complete-simple-robot-example",level:3},{value:"Kinematic Chains",id:"kinematic-chains",level:3},{value:"Visual and Collision Properties",id:"visual-and-collision-properties",level:3},{value:"Learning Objectives",id:"learning-objectives",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"urdf-components-links-and-joints",children:"URDF Components: Links and Joints"}),"\n",(0,s.jsx)(e.h2,{id:"understanding-robot-structure",children:"Understanding Robot Structure"}),"\n",(0,s.jsx)(e.p,{children:"URDF (Unified Robot Description Format) is an XML format used to describe robot models in ROS. It defines the physical and visual properties of a robot, including its links, joints, and their relationships."}),"\n",(0,s.jsx)(e.h3,{id:"links",children:"Links"}),"\n",(0,s.jsxs)(e.p,{children:["A ",(0,s.jsx)(e.strong,{children:"link"})," represents a rigid body in the robot. Each link has:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Physical properties (mass, inertia)"}),"\n",(0,s.jsx)(e.li,{children:"Visual properties (shape, color, mesh)"}),"\n",(0,s.jsx)(e.li,{children:"Collision properties (shape for collision detection)"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Basic link structure:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<link name="link_name">\n  <inertial>\n    <mass value="1.0" />\n    <origin xyz="0 0 0" rpy="0 0 0" />\n    <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0" />\n  </inertial>\n  <visual>\n    <origin xyz="0 0 0" rpy="0 0 0" />\n    <geometry>\n      <box size="1 1 1" />\n    </geometry>\n    <material name="blue">\n      <color rgba="0 0 1 1" />\n    </material>\n  </visual>\n  <collision>\n    <origin xyz="0 0 0" rpy="0 0 0" />\n    <geometry>\n      <box size="1 1 1" />\n    </geometry>\n  </collision>\n</link>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"joints",children:"Joints"}),"\n",(0,s.jsxs)(e.p,{children:["A ",(0,s.jsx)(e.strong,{children:"joint"})," connects two links and defines how they can move relative to each other. Joints have types and limits:"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Types of joints:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Fixed"}),": No movement between links"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Revolute"}),": Rotational movement around an axis (with limits)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Continuous"}),": Rotational movement without limits"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Prismatic"}),": Linear sliding movement (with limits)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Floating"}),": 6 DOF movement (for simulation)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Planar"}),": Movement in a plane"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Basic joint structure:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<joint name="joint_name" type="revolute">\n  <parent link="parent_link_name" />\n  <child link="child_link_name" />\n  <origin xyz="1 0 0" rpy="0 0 0" />\n  <axis xyz="0 0 1" />\n  <limit lower="-1.57" upper="1.57" effort="100" velocity="1" />\n</joint>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"complete-simple-robot-example",children:"Complete Simple Robot Example"}),"\n",(0,s.jsx)(e.p,{children:"Here's a simple robot with a base link and an arm:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_robot">\n  \x3c!-- Base link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <cylinder length="0.2" radius="0.1" />\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1" />\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- Arm link --\x3e\n  <link name="arm_link">\n    <visual>\n      <geometry>\n        <box size="0.1 0.1 0.5" />\n      </geometry>\n      <material name="red">\n        <color rgba="1 0 0 1" />\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- Joint connecting base and arm --\x3e\n  <joint name="base_to_arm" type="revolute">\n    <parent link="base_link" />\n    <child link="arm_link" />\n    <origin xyz="0 0 0.15" rpy="0 0 0" />\n    <axis xyz="0 1 0" />\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="1" />\n  </joint>\n</robot>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"kinematic-chains",children:"Kinematic Chains"}),"\n",(0,s.jsx)(e.p,{children:"Links and joints form kinematic chains that define how parts of the robot move relative to each other. The kinematic chain from base to end-effector is crucial for forward and inverse kinematics calculations."}),"\n",(0,s.jsx)(e.h3,{id:"visual-and-collision-properties",children:"Visual and Collision Properties"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Visual"}),": Defines how the link appears in visualizations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision"}),": Defines the shape used for collision detection"]}),"\n",(0,s.jsx)(e.li,{children:"These can be different shapes (e.g., detailed visual model, simplified collision model)"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(e.p,{children:"After completing this section, you should be able to:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Define links with physical and visual properties"}),"\n",(0,s.jsx)(e.li,{children:"Create different types of joints with appropriate parameters"}),"\n",(0,s.jsx)(e.li,{children:"Understand the relationship between links and joints"}),"\n",(0,s.jsx)(e.li,{children:"Build simple kinematic chains in URDF"}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>o,x:()=>l});var s=i(6540);const t={},r=s.createContext(t);function o(n){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);